###############################
Введение в смарт-контракты
###############################

.. _simple-smart-contract:

***********************
Простой смарт-контракт
***********************

Позвольте нам начать с простого примера, в котором мы присваиваем значение переменной и
предоставляем к ней доступ для других контрактов. Ничего страшного, если вам что-то
будет непонятьно в этом примере, мы разберем детали позднее. 

Пример создания контракта с общедоступной переменной.
===============

.. Пример кода:: solidity

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity >=0.4.16 <0.9.0;

    contract SimpleStorage {
        uint storedData;

        function set(uint x) public {
            storedData = x;
        }

        function get() public view returns (uint) {
            return storedData;
        }
    


В первой строке указано, что исходный код предоставляется по лицензии
GPL версии 3.0 Важно указывать спецификатор лицензии в машинно-читаемом формате
в случаях, когда планируется сделать написанный код публично доступным.

Следующая строка указывает, что данный код написан для языка Solidity версии 0.4.16,
или более новой, за ислючением версий выше 0.9.0. 

Это сделано, чтобы акцентировать внимание на том, что данный контракт не совместим с новой(фундаментально отличающейся) 
версией компилятора, в котором данный код может вести себя по другому.

:Примечание:`Pragmas<pragma>` широко используемая инструкция для компиляторов, 
указывающая каким образом следует интерпретировать исходный код (подробнее `pragma once <https://en.wikipedia.org/wiki/Pragma_once>`_).

Контракт(смарт-контракт) с позиции языка Solidity - это массив кода(его *функции*) и
данные(его *состояния*), которые размещены по определенному адресу в блокчейне Эфириума.
Строка ``uint storedData`` объявляет состояние переменной ``storedData`` типа ``uint``
(*u*\nsigned - беззнаковое, *int*\eger -  число, *256* битное). Вы можете рассматривать этот тип
данных, как одну ячейку базы данных, которую вы можете запрашивать и изменять с помощью вызова
функций программного кода, который управляет базой данных. В этом примере, контракт
объявляет функции ``set`` и ``get``, которые могу быть использованы для изменения
и запроса значения переменной.

Для получения доступа к элементу(например, к переменной состояния) данного контракта, вам не нужно,
как обычно добавлять префикс ``this``, вы просто обращаетесь к нему напрямую через его имя. В отличии от
некоторых других языков программирования, исключение префикса не является особенностью стиля, а приводит
к принципиально другому подходу в реализации доступа к элементам, но подробнее об этом позже.

Этот контракт ничего не делает, лишь(благодаря принципам работый инфраструктуры Эфириума) позволяет кому бы то ни было 
хранить едиственное число, к которому может получить доступ любой желающий, 
и исключает(какую-либо практическую) возможность уклониться от его публикации в открытый доступ.
Любой может вызвать функцию ''set'' снова и присвоить переменной другое значение, переписав ваше число,
но оно все равно будет сохранено в истории блокчейна. Позже, вы увидите, как можно наложить ограничения доступа
к функции таким образом, что только вы будете иметь право изменять это число.

.. Внимание::
    Будьте аккуратны с использованием текста в Unicode кодировке, так как одинаково выглядящие
    (или даже полностью одинаковые) символы могут иметь разный код в интерпретации Unicode и
    из-за этого шифруются как совершенно не идентичные байтовые массивы.
    
.. Замечание::
    Все идентификаторы(названия контрактов, имена функций и переменных) должны строго использовать
    систему кодирования ASCII. Также возможно хранить данные в переменных типа строка с использованием
    кодировки UTF-8. 
    
.. содержание:: ! Производная валюта(Сабкарренси)

Пример производной криптовалюты
===================

Следующий контракт представляет из себя простейшую форму криптовалюты.
Контракт позволяет создавать новые монеты только создателю контракта(схема создания может быть самая разнообразная).
Любой может отправить монеты кому угодно без необходимости регистрации с помощью имени пользователя и пароля,
все что вам нужно это пара ключей Эфириума.

.. Пример кода:: solidity

    // SPDX-License-Identifier: GPL-3.0
    pragma solidity ^0.8.4;

    contract Coin {
        // Ключевое слово "public" окрывает к переменной публичный
        // доступ из других контрактов
        address public minter;
        mapping (address => uint) public balances;

        // Событие(Event) позволяет клиентам реагировать на определенные,
        // объявленные вами, изменения в контракте
        event Sent(address from, address to, uint amount);

        // Код Constructor выполняется только в момент создания контракта
        constructor() {
            minter = msg.sender;
        }

        // Даная функция отправляет количество, определенное в переменной amount, вновь созданых монет на определеный адрес
        // Может быть вызвана только создателем контракта
        function mint(address receiver, uint amount) public {
            require(msg.sender == minter);
            balances[receiver] += amount;
        }

        // Обработчики ошибок позволяют вам вывести пользователю информацию
        // о причинах провала операции. Ответ возвращается к тому, кто вызвал функцию.
        error InsufficientBalance(uint requested, uint available);

        // Отправляет определенное в переменной amount количество существующих монет
        // с кошелька того, кто вызвал эту функцию на любой другой адрес.
        function send(address receiver, uint amount) public {
            if (amount > balances[msg.sender])
                revert InsufficientBalance({
                    requested: amount,
                    available: balances[msg.sender]
                });

            balances[msg.sender] -= amount;
            balances[receiver] += amount;
            emit Sent(msg.sender, receiver, amount);
        }
    }

В этом контракте есть некоторые новые концепции, давайте рассмотрим их одну за другой.

Строка ''address public minter;'' объявляет постоянную переменную типа адрес 'address<address>'.
Тип ``address``(адрес) представляет собой 160-битное значение, с которым запрещено проводить какие-либо 
арифметические операции. Эта переменная подходит для хранения адресов контрактов или хэш значений публичной
части пары ключей от каких-либо внешних аккаунтов.

Ключевое слово ''public''(публичный) автоматически генерирует функцию, которая позволяет вам получать доступ
к текущему значению постоянной переменной запросами из-за пределов контракта. Без этого ключевого слова, другие
контракты не смогут получить доступ к этой переменной. Код функции, сгенерированный компилятором, представляет нечто подобное:
(пока что не обращайте внимание на ``external`` и ``view``)

.. Пример кода:: solidity

    function minter() external view returns (address) { return minter; }

Вы можете самостоятельно добавить в контракт подобную функцию, но в итое вы получите функцию и постоянную переменную с
таким же именем. Вам не нужно этого делать, комрилятор сделает это за вас.

.. содержание:: Мэппинг(Сопоставление)

Следующая линия ``mapping (address => uint) public balances;`` также создает
переменную публичного состояния, но это более сложный тип данных. 
mapping <mapping-types> тип сопоставляет адреса к типу беззнаковое число `unsigned integers <integers>`
The :ref:`mapping <mapping-types>` type maps addresses to :ref:`unsigned integers <integers>`.

Мэппинг может рассматриваться как Хэш таблицы <https://en.wikipedia.org/wiki/Hash_table>, которые
виртуально инициализированны таким образом, что каждый возможный ключ существует с самого начала
и мэппирован к значению, чье байтовое представление будет состоять из одних нулей(0). Однако,
это невозможно, получить список всех ключей мэппирования, как и список всех значений. Запишите, то что
вы добавили к мэппингу или используйте этот тип в контексте, где знание списка значений мэппинга не является
необходимым. Или даже лучше, сохраните список или используйте более подходящий тип данных.

Функция getter (Отсылка `getter function<getter-functions>`) создается ключевым словом ``public``
и является более сложным случаем мэппинга. Выглядит это примерно так:

.. Пример кода:: solidity

    function balances(address account) external view returns (uint) {
        return balances[account];
    }


Вы можете использовать эту функцию, чтобы получать баланс какого-либо одного аккаунта.


.. Содержание:: Событие(event)
    
Строка ``event Sent(address from, address to, uint amount);`` объявляет
событие (event), которое выпускается в последней линии функции ``send``.
Клиенты Эфириума, такие как веб-приложения, могут слушать такие события,
выпускаемые в блокчейне за небольшую цену. Как только событие произошло,
слушающее событие приложение получает аргументы ``from``(от кого), ``to``(кому) 
and ``amount``(количество), с помощью которых можно отследить транзации.

Чтобы слушать это событие, вы можете использовать следующий код JavaScript,
который использует библиотеку web3.js <https://github.com/ethereum/web3.js/>,
чтобы создать объект контракта ``Coin``, и любой пользовательский интерфейс
автоматически вызывающий сгенерированную  функцию ``balances`` указанную выше: 

    Coin.Sent().watch({}, '', function(error, result) {
        if (!error) {
            console.log("Coin transfer: " + result.args.amount +
                " coins were sent from " + result.args.from +
                " to " + result.args.to + ".");
            console.log("Balances now:\n" +
                "Sender: " + Coin.balances.call(result.args.from) +
                "Receiver: " + Coin.balances.call(result.args.to));
        }
    })

.. Содержание:: Монета(coin)

constructor - это специальная функция, которая выполняется во время создания контракта и после 
этого уже не может быть вызвана. В этом случая, она навсегда сохраняет адрес создателя контракта.
Переменная ``msg`` (вместе с ``tx`` и ``block``) является специальной глабальной переменной, которая
содержит свойства, которые позволяют взаимодействовать с блокчейном. ``msg.sender`` это всегда адрес
с которого вызывается текущая(внешняя) функция.

Функция которая создает и устанавливает контракт, а также пользователь, которые это делает
и сам контракт могут вызывать функции ``mint`` и ``send``.

Функция ``mint`` отправляет вновь созданные монеты на другой адрес. Метод функции require определяет
условия для выполнения функции, и если условия не выполняются, то выполнение отменяется. В это примере,
``require(msg.sender == minter);`` - эта строчка подразумевает, что только создатель контракта может
вызывать функцию ``mint``. В основном, создатель может выпустить столько токенов, сколько он хочет,
но с другой стороны это может привести к феномену, называемому "overflow"(переполнение). Обратите внимание,
что из-за проверки арифметических соотношений транзакция может отмениться, если выражение
``balances[receiver] += amount;``(баланс получателя = инкремент на определенное число) переполняет значение
переменной, например, когда увеличение баланса кошелька получателя на произвольное точное число, приводит
значение баланса кошелька к такому числу, которое превышеает максимально возможное значение в
беззнаковом 256 битном числе минус 1. Такая ситуация также возмжона для строки ``balances[receiver] += amount;``
в функции ``send``.

Функция ошибка(error) позволяет вам сопроводить ошибку большим количеством подробностей о том, почему
условие или операция из контракта не выполнились. Ошибки используются вместе с 
откатом состояния(revert statement). Откат состояния без каких-либо дополнительных условий
отменяет и восстанавливает все изменения, в изначальное состояние, подобно функции ``require``,
а также  позволяет сопроводить это указанием имени ошибки и дополнительной информацией,
которую получает вызвавший функцию, которая привела к ошибке(в конечном итоге
информация об ошибке выводится на фронт-энд приложения или в блок эксплорер). Сопровождение
ошибки дополнительной информацией позволяет облегчить отладку и правильно на нее отреагировать.

Функция ``send``(отправить) может быть использована любым пользователем(у кого уже есть
немного этих монет), чтобы отправить монеты кому-нибудь еще. Если у отправляющего недостаточно 
монет для отправки заявленной суммы, то условие ``if`` устанавливается в ``True``. В результате будет вызвана функция
``revert``, которая откатит все изменения инициированные пользователем, и отправка монет вернет ошибку 
``InsufficientBalance``, указывающую на недостаточность средств для отправки.

.. Замечание::
    Если вы используете этот контракт для отправки монет на определенный адрес, 
    то вы ничего не увидите, если попробуете получить данные об адресе через блокчейн
    эксплорер, потому что запись, которой вы отправляете монеты и измененные балансы
    сохраняются в данных конкретного контракта. Используя события, вы можете создать
    свой "блокчейн эксплорер", который будет отслеживать переводы и балансы вашей новой
    монеты, но вы должны будете отслеживать адреса контрактов вашей монеты, а не адреса
    владельцев монет.
 
.. основы блокчейна:

*****************
Основы блокчейна
*****************

Блокчейны как концепт довольно просты для понимания программистами. Причина в том, что основные
сложности(майнинг, хэширование <https://en.wikipedia.org/wiki/Cryptographic_hash_function>, эллиптическая криптография
<https://en.wikipedia.org/wiki/Elliptic_curve_cryptography>, пиринговые сети <https://en.wikipedia.org/wiki/Peer-to-peer> и прочее) 
для понимания здесь в определенных особенностях и ожиданиях от платформы. Как только
вы принимаете эти особенности, как данность, вам не нужно больше беспокоиться о тех технологиях,
которые лежат "под капотом" - или вам обязательно знать как Amazon AWS работает внутри, чтобы использовать его?

.. Содержание:: Переводы(Транзакции)

Транзакции
============

Блокчейн - это глобально распределенная база транзакций. Это значит, что каждый может 
прочитать записи в базе с помощью участия в сети. Если вы хотите поменять что-то в 
базе данных, вы должны создать так называемую транзакцию, которую должны принять остальные
участники сети. Слово "транзакция" подразумевает, что изменение, которое вы хотите сделать
(допустим вы хотите изменить два значения в одно и то же время) либо не будет выполнена вообще
или будет полностью принята. К тому же, пока ваша транзакция применяется для изменения базы
данных, никакая другая транзакция не может на нее повлиять.

В качестве примера, представьте таблицу, которая выводит балансы всех аккаунтов
в электронной валюте. Если запрошен перевод с одного аккаунта на другой, транзакционная природа
базы данных проверяет, что сумма списанная с одного аккаунта, всегда добавляется на другой аккаунт.
Если в силу какой-либо причины, добавление суммы перевода на целевой аккаунт невозможно,
с отправляющего аккаунта сумма также не списывается.

Более того, транзакция всегда подписана криптографическим ключем отправителя(создателя).
Это прямолинейно указывает на защиту базы от специфичных модификаций базы данных.
В примере электронной валюты, простая проверка удостоверяет, что только тот, кто владеет
ключами к аккаунту может переводить с него деньги.

.. Содержание:: ! Блок

Блоки
======

Одной из основных проблем, которую необходимо решить, это (в терминах Биткоина) так называемая
"Двойное списание": Что случается, если две транзакции записанные в сеть, хотят опустошить какой-либо аккаунт?
Только одна из транзакций может быть признана настоящей, обычно та, которую приняли первой. Проблема в том,
что "первая" транзакция, неприменимый термин в пиринговой сети.

В вашем случае об этой проблеме просто не следует беспокоиться. Принимая на любой ноде заявка на перевод будет
выбрана в сети блокчейн за вас, разрешая этот конфликт. Транзакция будет упакована в так называемый "блок" и затем она выполнена
и записана на все существующие ноды сети. Если две транзакции противоречат друг другу, та, которая по идее должна быть
выполнена во вторую очередь будет отклонена и не появится в новом блоке.

Эти блоки формируют линейную последовательность, откуда и берется слово "блокчейн"(буквально - цепочка блоков).
Блоки добавляются к цепочке через довольно регулярные интервалы - для Эфириума это примерно каждые 17 секунд.

Как часть "механизма выбора заявки"(который называется майнинг), иногда может происходить отмена блока, но только в
самом начале формирования ("наконечнике") цепочки блоков. Чем больше блоков добавлено до конкретного текущего блока,
тем менее вероятно, что этот блок будет отменен. Таким образом, может случиться так, что ваша транзакция
отменена или даже удалена из блокчейна, но чем дольше вы ждете, тем менее вероятность того, что это случится.

.. Замечание::
    Нет никаких гарантий, что транзакция будет в конечном счете включена в следующий блок или другой какой-либо из более поздних,
    блоков, так как это зависит не от отправителя транзакции, а майнеров, которые решают в какой блок транзакция будет включена
    
    Если вы хотите запланировать будущие вызовы вашего контракта, вы можете использовать инструмент автоматизации
    смарт контракта или сервис oracle.
    
.. _the-ethereum-virtual-machine:

.. содержание:: !evm, ! ethereum virtual machine

****************************
Виртуальная машина Эфириума
****************************

Обзор
========

Виртуальная машина Эфириума или EVM - это исполнительная среда для смарт-контрактов в Эфириуме.
Она представляет собой не просто сандбок, а действительно полностью изолированную среду.
Это значит, что код, выполняемый внутри EVM не имеет доступа к сети, файловой системе и другим процессам.
Смарт-контракты даже имеют ограниченный доступ к другим смарт-контрактам.

.. содержание:: ! аккаунт, адрес, хранение, баланс

.. _аккаунты:

Аккаунт
========

Существует два типа аккаунтов в Эфириуме, которые разделяют одно адресное пространство.
**Внешние аккаунты**, которые контролируются парой публичного и приватного ключа(например, людьми)
и **аккаунты контрактов**, которые контролируются кодом хранящимся вместе со счетом.

Адрес внешнего аккаунта определяется из публичного ключа, в то время, как адрес контракта определяется
в момент создания контракта(контракт доставляется в аккаунты из адреса создателя контракта и оттуда же приходит и номер
транзакции, так называемый нонс("nonce")

Независимо от того хранит аккаунт код или нет, оба типа аккаунтов интерпретируются EVM одинаково.

Каждый аккаунт имеет постоянное хранилище в формате ключ значение, адресующее 256-битные слова к 256-битным словам,
называется оно **хранилище**(storage)

Более того, каждый аккаунт имеет значение баланса (**balance**) в Эфире(выраженный в "Wei" если быть точным,
1 эфириум это 10 в 18-ой степени "wei"), которое может быть изменено отправлением транзакции включающей в себя Эфириум.

.. содержание:: ! транзакция

Транзакции
============

Транзакция - это сообщение, которое отправляется с одного аккаунта на другой(это может быть тот же аккаунт
или пустой, подробнее ниже). Сообщение может включать двоичные данные(которые назваются "полезная нагрузка"(payload)) и Эфир.

Если целевой аккаунт содержит код, этот код выполняется и полезная нагрузка представляет из себя вводные данные.

Если целевой аккаунт не указан(транзакция не имеет получаетеля или поле получателя установлено в "null"),
транзакция создает новый контракт(**new contract**).

Как уже было упомянуто, адрес этого контракта не нулевой(пустой) адрес этого контракта не ноль, а адрес
получаемый от отправителя и номер отправленной транзакции("nonce"). "Полезная нагрузка"(payload) такой
транзакции создания контракта, исполняется как двоичный код в виртуальной машине Эфириума. Результат
исполнения этого кода сохраняется навсегда, как код этого контракта. Это значит,
что с целью создания контракта, вы отправляете не сам код контракта, а код, который после исполнения
на виртуальной машине Эфириума возвращает код контракта.

.. Замечание::
  В процессе создания контракта, его код все еще пустой.
  Из-за этого, вам не следует делать вызовы в контракт, находящийся в процессе создания,
  до того момента пока конструктор не закончил выполнять код создания контракта.
  
.. индекс:: ! gas, ! gas price (Газ, цена газа)

Gas(Газ)
===

В процессе создания, каждая транзакция облагается определенным размером газа **gas**,
который должен быть оплачен инициатором транзакции(''tx.origin'').
Пока виртуальная машина Эфириума выполняет транзакцию, газ постепенно расходуется в соостветствии
с определенными правилами. Если газ израсходован в какой-либо момент исполнения(например, он становится отрицательным занчением),
запускается триггер закончившегося газа, который завершает исполнение кода и отменяет все
изменения, которые были сделаны для исполнения транзакции в рамках данного вызова.

Этот механизм создает экономическую мотивацию использования процессорного времени виртуальной машины Эфириума и
также компенсирует затраты для исполнителей предоставляющих процессорные мощности (например майнеры и держатели)ю
Так как каждый блок имеет максимальное количество газа, это также ограничивает количество работы, которую нужно 
выполнить, чтобы валидировать блок.

Цена за газ **gas price** это значение устанавливаемое инициатором транзакции,который должен
заплатить сумму рассчитываемую по формуле ''gas_price * gas'' перед выполнением кода в виртуальтной машине Эфириума

Если после выполнения осталось сколько-то газа, он возвращается к инициатору транзакции.
Если выполнение контракта отменяется, то уже потраченный газ не возвращается.

Так как исполнители кода виртуальной машины эфириума могут выбирать включать транзакцию в блок или нет,
отправители транзакции не могут повредить системе, устанавливая низкие цены на газ.

.. содержание:: ! хранилище, ! память, ! стек

Хранилище, память и стек
=============================

Виртуальная машина Эфириума имеет три места, где она может хранить данные:
хранилище, память и стек.

Каждый аккаунт имеет место назваемое хранилище **storage**, которое находится между выховами функций
и транзакциями.
Хранилище - это место для хранения пар ключ-значение, которое сопоставляет 256-битные слова к 256-битным словам.
Хранилище нельзя перебрать изнутри контракта, он достаточно трудозатратный по чтению из него, и даже больше
инициализировать и модифицировать его. Из-за этой трудозатратности, вам следует минимизировать объем информации,
хранящейся в нем, до объема необходимого только для запуска контракта. Храните данные типа произведенных расчетов,
кэшей и собранных данных за пределами контракта. Контракт не может ни читать, ни писать в любое хранилище за пределами
него самого.

Вторая среда для хранения данных назвается **память**(**memory**), контракт
получает очищенную новую память для каждого сообщения вызова. Память эта
линейная и может быть адресована на уровне байтов, но чтение лимитировано шириной
256 бит, в то время как запись может быть 8 бит или 256 бит. Память расширяется на одно
слово(256-бит), в момент доступа(на чтение или запись) к предыдущему не тронутое 
слово в памяти(например, смещение внутри слова). В момент расширения, должна
быть оплачена стоимость газа. Память тем больше стоит, чем больше она задействуется
(она масштабируется квадратично).

Виртуальная машина Эфириума это не регистровая машина, а стековая, поэтому все 
вычисления выплняются в области данных называемой **stack**. Ее максимальный размер
1024 элемента содержащие 256 битные слова. Доступ к стеку ограничен к верхнему концу в
следующем порядке:
Возможно скопировать один из верхних 16-ти элементов на самый верх стека или поменять местами
верхний элемент стека с одним из 16 элементов под ним. Все другие операции берут два из 16-ти верхних
(или один элемент или больше, в зависимости от операции) элементов из стека и проталкивают результат
на верх стека. Конечно возможно переместить элементы стека в хранилище или память
для того, чтобы можно было получить доступ к более глубоким элементам стека(глубже верхних
16-ти элементов), но нельзя просто получить произвольный доступ к к более глубоким элементам
стека без того, чтобы убрать верхний стек. 

.. содержание:: ! Инструкция

Набор инструкций
===============

Набор инструкций для виртуальной машины Эфириума минимален, для того чтобы
избежать неправильного или насоответствующего применения, что может приводить
к проблемам при принятии консенсуса. Все инструкции работают с базовыми типами данных,
256-битными словами или слоями памяти (или других байтовых массивов).

Возможны обычные арифметические, битовые, логические или операции сравнения,
обусловленные и необусловленные переходы. Более того, контракты могут получать доступ к 
релевантным свойствам конкретного блока, типа его номера или метки времени.

Для полного списка, пожалуйста посморите документ "список операционных кодов" :ref:`list of opcodes <opcodes>`,
как часть внутренней сборочной документации.

.. содержание:: ! вызовы, вызовы сообщений, функции

Вызовы сообщений
=============

Контракты могут вызывать другие контракты или отправлять Эфир на
неконтрактные аккаунты с помощью вызовов сообщений. Вызовы сообщений похожи на
транзакции, поэтому они имеют источник, цель, полезную нагрузку,
Эфир, газ и возвращаемые данные. По факту, каждая транзакция состоит из
верхнеуровнего сообщения, которое в свою очередь может вызывать последующие
вызовы сообщений.

Контракт может решить как много из оставшегося **газа** должно быть отправлено
с внутренним вызовом сообщения и как много он должен сохранить. Если
случается исключение недостаточного количества газа во внетреннем вызове(или
любое другое исключение), об этом будет сообщено значением ошибки возвращенным на верх стека.
В этом случае, будет потрачен только газ отправленный вместе с вызовом.
В Solidity, в таких случаях вызов контракта приводит к ручному исключению по умолчанию,
и такие исключения "накачивают" стек вызовов.

Как уже было сказано, вызванный контракт(который может быть тем же, который и вызывает)
получит свежую чистую среду памяти и получит доступ к вызову полезной нагрузки сообщения,
которая будет доступна в отдельной среде называемой **calldata**(вызываемые данные).
После тоо как выполнение завершено, полезная нагрузка может вернуть данные, которые
будут сохранены определенном месте в предварительно выделенной памяти вызывающего контракта.
Все такие вызовы полностью синхронны.

Вызовы **ограничены** глубиной 1024, это подразумевает, что для более сложных операций, 
циклы должны предпочитать обратные вызовы. Более того, только 63/64 газа может быть
перенаправленно в вызов сообщения, что приводит на практике к ограничениям глубины чуть менее чем 1000.

.. содердажние:: Делегированный вызов, код вызова, библиотека

Делегированный вызов / Код вызова и библиотеки
=====================================

Существует специальный вариант вызова сообщения, назваемый делегированный вызов (**delegatecall**),
который аналогичен вызову сообщения, за исключением того факта, что код целевого адреса выполняется в контексте
(например на адресе) вызывающего контракта и переменные ''msg.sender'' и ''msg.value'' не изменяют своих значений.

Это значит, что контракт может динамически загружать код из различных адресов во время исполнения. Храненилище,
текущий адрес и баланс в то же время являются частью вызывающего контракта, из вызываемого адреса берется только 
исполняемый код.

Это делает возможным применение функцию "библиотека" в языке Solidity:
Многократно используемый библиотечный код, который может быть применен к хранилищу контракта, напрример
в целях применения сложных структур данных.

.. содержание:: логи

Логи
====

Предусмотрена возможность хранить данные в специально индексируемых структурах данных,
которые адресуют все до уровня блоков. Эта функция называется **logs**(логи)
и используется Solidity для применения событий:ref:`events <events>`. 
Контракты не могут получить доступ к данным логов после того, как они были созданы,
но их можно эффективно получить из-за пределов блокчейн.
Так как часть данных логов сохранена в фильтре Блума <https://en.wikipedia.org/wiki/Bloom_filter>,
это позволяет осуществлять поиск в этих данных в эффективном и криптографически защищенном виде,
и сетевые пиры, которые не загружают весь блокчейн(так называемые "light nodes") могут находить эти логи.

.. содержание:: создание контракта

Создать
======

Контракты даже могут создавать другие контракты с использованием специальных опткодов(например,
они не просто вызывают нулевой адрес, как сделала бы транзакция). Единственная разница между
этим **создать вызов** и нормальным вызовом сообщения заключается в том, что данные полезной
нагрузки выполняются и результат сохранятется, как код и вызвавший/создатель получает в стек адрес нового контракта.

.. содержание:: саморазрушение, само-разрушение и деактивация

Деактивация и само-разрушнеие
============================

Едиственый способ удалить код из блокчейна, это когда контракт на адресе
совершает операцию саморазрушения ''selfdestruct''. Оставшийся Эфир сохранен
на адресе и отправлен на обозначенный адрес и затем хранилище и код удаляются
из состояния. Удаление контракта в теории звучит, как хорошая идея, но это
несет в себе потенциальные риски, например, если кто-то отправляет Эфир на
удаленные контракты, то Эфир будет навсегда потерян.

.. предупреждение::
    Даже если контракт удален с помощью функции ''selfdestruct'', он все равно
    часть истории блокчейна и вероятно сохранен большинством нод Эфириума.
    Поэтому использование функции ''selfdestruct'' это не то же самое, что удаление
    данных с жесткого диска.

.. замечание::
    Даже если код контракта не содержит вызова ''selfdestruct'',
    он все равно может выполнить операцию с использованием делегированного вызова
    ''delegatedcall'' или ''callcode''(вызов кода)
Если вы хотите деактивировать ваши контракты, вы должны вместо **отключения** их
с помощью изменения некоторых внутренних состояний, которые приводят к возврату 
к изначальному состоянию всех функций. Это делает невозможным использовать контракт,
и он сразу же возвращает Эфириум.

.. содержание:: ! предварительно скомпилированные контракты, ! прекомпиляция, ! контракт;прекомпилированный

.. _прекомпилированныеКонтракты:

Предварительно скомпилированные контракты
=====================

Существует небольшой набор адресов контрактов, которые имею особенности:
Диапазон адресов между ''1'' и (включительно) ''8'' содержат
"прекомпилированные контракты" которые можно вызвать, как и любые другие
контракты, но их поведение(и потребление газа) не определено
виртуальной машиной Эфириума сохраненной на этом адресе(они не содержат кода),
но вместо этого они применены в среде выполнения виртуальной машины сами по себе.

Разные чейны совместимые с виртуальной машиной Эфириума могут использовать
различный набор прекомпилированный контрактов. Это также возможно, что новые
прекомпилированные контракты добавляются в главный чейн Эфириума в будущем,
но вы можете обоснованно ожидать, что они всегда будут в диапазоне между
''1'' и ''0xffff''(включительно).
